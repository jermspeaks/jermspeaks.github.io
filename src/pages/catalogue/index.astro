---
import { getCollection } from "astro:content";
import { Image, getImage } from "astro:assets";
import CatalogueFilter from "../../components/CatalogueFilter.svelte";
import BaseBody from "../../components/BaseBody.astro";
import BaseHead from "../../components/BaseHead.astro";
import Footer from "../../components/Footer.astro";
import Header from "../../components/Header.astro";
import TitleHeading from "../../components/TitleHeading.astro";
import { SITE_TITLE, SITE_DESCRIPTION } from "../../consts";

const allBooks = await getCollection("catalogueBook");
const booksWithImages = await Promise.all(
  allBooks
    .filter((book) => !book.data.draft)
    .map(async (book) => {
      // Safely convert reviewDate to ISO string, handling invalid dates
      // Fall back to pubDate if reviewDate is not available
      const dateToUse = book.data.reviewDate || book.data.pubDate;
      let reviewDateString: string;
      
      if (!dateToUse) {
        // Missing reviewDate and pubDate, use epoch as fallback
        console.warn(`Missing reviewDate and pubDate for book: ${book.slug}`);
        reviewDateString = new Date(0).toISOString();
      } else if (dateToUse instanceof Date) {
        // Check if the Date is valid
        if (isNaN(dateToUse.getTime())) {
          // Invalid date, use a fallback
          console.warn(`Invalid reviewDate for book: ${book.slug}, date: ${dateToUse}`);
          reviewDateString = new Date(0).toISOString();
        } else {
          reviewDateString = dateToUse.toISOString();
        }
      } else {
        // Try to create a Date from the value
        const date = new Date(dateToUse);
        if (isNaN(date.getTime())) {
          // Invalid date, use a fallback
          console.warn(`Invalid reviewDate for book: ${book.slug}, value: ${dateToUse}`);
          reviewDateString = new Date(0).toISOString();
        } else {
          reviewDateString = date.toISOString();
        }
      }

      let coverImage: { src: string; width?: number; height?: number } | null = null;
      if (book.data.coverImage) {
        try {
          const image = await getImage({ src: book.data.coverImage });
          // Create a plain object with only serializable primitives
          const width = typeof book.data.coverImage.width === 'number' ? book.data.coverImage.width : undefined;
          const height = typeof book.data.coverImage.height === 'number' ? book.data.coverImage.height : undefined;
          coverImage = {
            src: String(image.src),
            ...(width !== undefined && { width }),
            ...(height !== undefined && { height }),
          };
        } catch (error) {
          console.warn(`Failed to resolve cover image for ${book.slug}:`, error);
        }
      }

      // Build a plain object with only primitives
      const bookData: {
        slug: string;
        data: {
          title: string;
          bookAuthor?: string;
          authors?: string[];
          rating?: number | string;
          pubDate: string;
          coverImage?: { src: string; width?: number; height?: number } | null;
        };
      } = {
        slug: String(book.slug),
        data: {
          title: String(book.data.title),
          pubDate: reviewDateString,
        },
      };
      
      // Add optional fields only if they exist
      if (book.data.bookAuthor) {
        bookData.data.bookAuthor = String(book.data.bookAuthor);
      }
      if (book.data.authors && Array.isArray(book.data.authors)) {
        bookData.data.authors = book.data.authors.map(String);
      }
      if (book.data.rating !== undefined && book.data.rating !== null) {
        bookData.data.rating = typeof book.data.rating === 'string' 
          ? book.data.rating 
          : typeof book.data.rating === 'number' 
            ? book.data.rating 
            : String(book.data.rating);
      }
      if (coverImage) {
        bookData.data.coverImage = coverImage;
      } else {
        bookData.data.coverImage = null;
      }
      
      return bookData;
    })
);
const books = booksWithImages;
---

<!doctype html>
<html lang="en">
  <head>
    <BaseHead
      description="This page lists games, books, shows... stuff I've played, watched, read, listened to."
      title="Catalogue"
    />
  </head>
  <BaseBody>
    <Header />
    <main class="max-w-[120ch] mx-auto px-4">
      <TitleHeading>
        <a href="/catalogue">Catalogue</a>
      </TitleHeading>
      <CatalogueFilter client:only="svelte" books={books} />
    </main>
    <Footer />
  </BaseBody>
</html>

